// This is free and unencumbered software released into the public domain.
// For more information, please refer to <http://unlicense.org/>

#ifndef OTLS_ONSAG_ANALYSISCONTROLLER_H_
#define OTLS_ONSAG_ANALYSISCONTROLLER_H_

#include <vector>

#include "wx/wx.h"

#include "onsag/sag_span.h"
#include "onsag/sagging_analysis_result.h"
#include "onsag/span_sagger.h"

/// \par OVERVIEW
///
/// This struct is an analysis job, which includes the inputs (that change from
/// job to job) and the result to calculate.
struct AnalysisJob {
  /// \var result
  ///   The sagging result to calculate.
  SaggingAnalysisResult* result;

  /// \var temperature
  ///   The analysis temperature.
  const double* temperature;
};


/// \par OVERVIEW
///
/// This class is a worker thread for an analysis.
///
/// \par JOBS
///
/// This thread can accept multiple jobs to run. Once all of the jobs are
/// completed, this thread will pause and wait to be joined back into the main
/// application thread.
///
/// \par MESSAGES
///
/// This thread logs any error messages from the analysis.
class AnalysisThread : public wxThread {
 public:
  /// \brief Constructor.
  AnalysisThread();

  /// \brief Adds an analysis job to the thread.
  /// \param[in] job
  ///   The job.
  /// This must be done before the Run() method.
  void AddAnalysisJob(AnalysisJob* job);

  /// \brief Gets the span.
  /// \return The span.
  const SagSpan* span() const;

  /// \brief Gets the error messages.
  /// \return The error messages.
  const std::list<ErrorMessage>* messages() const;

  /// \brief Gets the sagger.
  /// \return The sagger.
  const SpanSagger* sagger() const;

  /// \brief Sets the span.
  /// \param[in] span
  ///   The sag span.
  void set_span(const SagSpan* span);

 protected:
  /// \brief Does an analysis job.
  /// \param[in] index
  ///   The job index.
  void DoAnalysisJob(const int& index);

  /// \brief Begins the thread processing.
  /// \return The thread exit code.
  /// This function is called directly after Run().
  virtual ExitCode Entry();

  /// \var jobs_
  ///   The analysis jobs.
  std::list<AnalysisJob*> jobs_;

  /// \var span_
  ///   The sag span to analyze.
  const SagSpan* span_;

  /// \var messages_
  ///   Error messages encountered during the analysis.
  mutable std::list<ErrorMessage> messages_;

  /// \var sagger_
  ///   The sagger that is used in the analysis. This is used solve for the
  ///   sagging results.
  SpanSagger sagger_;
};


/// \par OVERVIEW
///
/// This class handles the sagging analysis and generates cached results.
///
/// \par CACHED RESULTS
///
/// This class stores all of the analysis results. The results do not update
/// automatically. Results can only be generated by using the RunAnalysis()
/// method. This is done because:
///  - a span is not always selected
///  - results can be computationally expensive and need to be calculated only
///    as needed
///
/// MULTI-THREADING
///
/// This class uses worker threads to calculate the results. The number of
/// threads depends on the available CPUs. A list of analysis jobs are generated
/// and then split evenly among the available threads. This speeds things up so
/// the calculations are less of a bottleneck to the main application thread.
class AnalysisController {
 public:
  /// \brief Constructor.
  AnalysisController();

  /// \brief Destructor.
  ~AnalysisController();

  /// \brief Clears the results.
  void ClearResults();

  /// \brief Gets the sagging analyis result.
  /// \param[in] index
  ///   The result index.
  /// \return The sagging analysis result. If the index did not match up to
  ///   the results list, or the result is not a valid sagging result, a
  ///   nullptr is returned.
  const SaggingAnalysisResult* Result(const int& index) const;

  /// \brief Gets the analysis results.
  /// \return The analysis results. This gets access to all results, even
  ///   invalid ones.
  const std::vector<SaggingAnalysisResult>* Results() const;

  /// \brief Runs the sagging analysis.
  void RunAnalysis();

  /// \brief Sets the activated span.
  /// \param[in] span
  ///   The span.
  void set_span(const SagSpan* span);

  /// \brief Gets the span.
  /// \return The span. If no span is set, a nullptr is returned.
  const SagSpan* span() const;

 private:
  /// \brief Updates the analysis temperatures.
  /// \return The success status of the update.
  bool UpdateTemperatures();

  /// \var max_threads_
  ///   The maximum number of threads that can be used in the analysis.
  int max_threads_;

  /// \var results_
  ///   The analysis results.
  mutable std::vector<SaggingAnalysisResult> results_;

  /// \var span_
  ///   The sag span being analyzed.
  const SagSpan* span_;

  /// \var temperatures_
  ///   The temperatures to be analyzed.
  std::list<double> temperatures_;
};

#endif  // OTLS_ONSAG_ANALYSISCONTROLLER_H_
